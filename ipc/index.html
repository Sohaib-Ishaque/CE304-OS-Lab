<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>IPC</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
          <h1>Introduction to Interprocess Communication</h1>
          <h5>Parham Alvani @1995parham</h5>
          <span>Fall 2016</span>
        </section>
        <section>
          <ul>
            <li>Taxonomy of IPC Facilities</li>
            <li>Comminucation</li>
          </ul>
        </section>
        <section>
          <h1>Taxonomy of IPC Facilities</h1>
          <ul>
            <li>Comminucation</li>
            <li>Synchronization</li>
            <li>Signals</li>
          </ul>
        </section>
        <section>
          <dl>
            <dt>Communication</dt>
            <dd>These facilities are concerned with exchaning data between processes</dd>
            <dt>Synchronization</dt>
            <dd>These facilities are concerned with synchronizing the actions of processes or threads</dd>
            <dt>Signals</dt>
            <dd>Although signals are intended primarily for other purposes, they can be used as a synchronization technique in certain circumestances</dd>
          </dl>
        </section>
        <section>
          <img src="img/ipc.jpg" alt="IPC">
        </section>
        <section>
          <h1>Comminucation</h1>
          <ul>
            <li>Pipes</li>
            <li>FIFOs</li>
            <li>Shared Memory</li>
          </ul>
        </section>
        <section>
          <p>The various comminucation facilities allow processes to exchange data with one another</p>
          <dl>
            <dt>Data-transfer facilities</dt>
            <dd>
            The key factor distinguishing these facilities is the notion of writing and reading.
            In order to communicate, one process writes data to the IPC facility, and another process reads the data
            </dd>
            <dt>Shared memory</dt>
            <dd>
            Shared memory allows processes to exchange information by placing it in a region of memory that is
            shared between the processes.
            Shared memory can provide <strong>very fast comminucation</strong> because it doesn't require system calls or data transfer
            between user and kernel memory.
            </dd>
          </dl>
        </section>
        <section>
          <p>DPDK is a set of libraries and drivers for fast packet processing</p>
          <img src="img/dpdk.png" alt="DPDK">
        </section>
        <section>
          <p>We can further break data-transfer facilities into the following subcategories</p>
          <ul>
            <li>
            Byte Stream
            <ul>
              <li>pipes</li>
              <li>FIFOs</li>
              <li>stream sockets (TCP)</li>
            </ul>
            </li>
            <li>
            Message
            <ul>
              <li>System V message queue</li>
              <li>POSIX message queues</li>
              <li>datagram sockets (UDP)</li>
            </ul>
            </li>
            <li>
            Pseudoterminals
            </li>
          </ul>
        </section>
        <section>
          <h1>Let's code :)</h1>
          <h2>Pipes as a Byte Stream Data Transfer Facility</h2>
        </section>
        <section>
          <pre><code class="c">
          #include &lt unistd.h &gt

          int pipe(int filedes[2]);
          /*
           * Returns 0 on success, or -1 on error
           */
          </code></pre>
        </section>
        <section>
          <pre><code class="c">
          #include &lt stdio.h &gt

          FILE *popen(const char *command, const char *mode);
          /*
           * Returns file stream or NULL on error
           * mode is w: calling process write to command
           * mode is r: calling process read from command
           */

          int pclose(FILE *stream);
          /*
           * Returns termination status of child process, or -1 on error
           */
          </code></pre>
        </section>
        <section>
          <p>Separating messages in a byte stream:</p>
          <ul>
            <li>delimiter character</li>
            <li>header with length field</li>
            <li>fixed-length messages</li>
          </ul>
          <p>Synchronization between the reader and writer processes is automatic</p>
        </section>
        <section>
          <h1>Let's code :)</h1>
          <h2>FIFOs as a Byte Stream Data Transfer Facility</h2>
          <h2>FIFOs == Named pipes !</h2>
        </section>
        <section>
          <pre><code class="c">
          #include &lt sys/stat.h &gt

          int mkfifo(const char *pathname, mode_t, mode);
          /*
           * Returns 0 on success, or -1 on error
           */
          </code></pre>
        </section>
        <section>
          <p>
          Although shared memory provides fast communication, this speed advantage
          is offset by the need of synchronize operations on the shared memory.
          </p>
        </section>
        <section>
          <p>
          Redis is an open source (BSD licensed), in-memory data structure store,
          used as a database, cache and message broker.
          </p>
          <img src="img/redis-white.png" alt="Redis">
        </section>
        <section>
          <h1>Let's code :)</h1>
          <h2>Shared Memory :|</h2>
        </section>
        <section>
          <table>
            <thead>
              <tr>
                <th style="text-align:left">shm API</th>
                <th style="text-align:left">description</th>
              </tr>
            </thead>
            <tbody>
            <tr>
              <td style="text-align:left">shmget</td>
              <td style="text-align:left">allocate shared memory segment</td>
            </tr>
            <tr>
              <td style="text-align:left">shmat</td>
              <td style="text-align:left">attach to the shared memory with the given shared memory identifier</td>
            </tr>
            <tr>
              <td style="text-align:left">shmctl</td>
              <td style="text-align:left">perform control operations on the shared memory segment</td>
            </tr>
            <tr>
              <td style="text-align:left">shmdt</td>
              <td style="text-align:left">detaches from the shared memory</td>
            </tr>
            </tbody>
          </table>
          <p>To use the above API we must include <code>&lt sys/ipc.h &gt</code> and <code>&lt sys/shm.h &gt</code> header files.</p>
        </section>
        <section>
          <pre><code class="c">
          int shmget(key_t key, size_t size, int shmflg);
          </code></pre>
        </section>
        <section>
          <p><code>shmget</code> returns the shared memory ID on success.</p>
          <ul>
            <li>The first argument <code>key</code> must be unique. This <code>key</code> can be generated using the <code>ftok()</code> call.</li>
            <li>The <code>size</code> argument is the size of the shared memory segment (it is rounded to the multiples of PAGE_SIZE. Usually PAGE_SIZE is 4k).</li>
            <li>The <code>shmflg</code> is usually set with the IPC_CREAT flag. </li>
            <li>If the <code>key</code> already exist, the <code>errno</code> is set to EEXIST and returns -1.</li>
          </ul>
        </section>
        <section>
          <h3>ICPS !?</h3>
          <p>ipcs - show information on IPC facilities</p>
          <dl>
            <dt>-m, --shmems</dt>
            <dd>Write information about active shared memory segments.</dd>
            <dt>-q, --queues</dt>
            <dd>Write information about active message queues.</dd>
            <dt>-s, --semaphores</dt>
            <dd>Write information about active semaphore sets.</dd>
            <dt>-a, --all</dt>
            <dd>Write information about all three resources (default).</dd>
          </dl>
        </section>
        <section>
          <pre><code class="c">
          void *shmat(int shmid, const void *shmaddr, int shmflg);
          </code></pre>
        </section>
        <section>
          <p>The API <code>shmat</code> performs the attachement to the shared memory segment.</p>
          <ul>
            <li>the first argument <code>shmid</code> is the id returned from shmget.</li>
            <li>the second argument is the attach address, and is usually kept to NULL.</li>
            <li>the shmflg is also kept to 0 when doing read and write operations on the shared memory.</li>
          </ul>
        </section>
        <section>
          <h3>References</h3>
          <h5><a href="https://devnaga.gitbooks.io/linux-systems-programming-with-c-sample">Linux Systems Programming with C Sample</a></h5>
          <h5>Linux Programming Interface, by Michael Kerrisk, 2010</h5>
        </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
